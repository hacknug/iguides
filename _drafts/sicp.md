*Нормальный порядок  вычислений* - реализация подстановочной  модели применения
процедуры,  при которой  интерпретатор сперва  производит замену  (подстановку)
"дырок"  процедур на  их  тела,  а затем  производит  редукцию  и вычисления  с
конкретными значениями аргументов. Это может привести к избыточным вычислениям,
например,  при интерпретации  выражения  `(#(*  x x)  (+  2  3))` сперва  будет
произведена  замена  параметра  `x`  в   теле  анонимной  функции  на  значение
аргумента,  а только  затем вычисление:  `#(*  (+ 2  3)  (+ 2  3))`. Как  можно
увидеть,  выражение  `(+ 2  3)`  будет  вычислено  дважды. Поэтому  чаще  всего
реализуется аппликативный порядок вычисления.  Тем не менее, нормальный порядок
в некоторых случаях может быть полезен и даже незаменим.

При *аппликативном  порядке вычислений* сперва вычисляются  значения аргументов
процедур,  а  затем  их  подстановка,  и так  рекурсивно  вплоть  до  получения
результата, то есть  в выражении из предыдущего примера  значение параметра `x`
будет заменено на результат вычисления `(+ 2 3)`.

*Рекурсивный  процесс*  характеризуется  тем,  что  строит  цепочку  отложенных
операций  (при  каждом  рекурсивном  вызове),   а  затем  выполняет  их,  когда
рекурсивные  вызовы   возвращают  результат.  Этот  тип   процесса  требует  от
интерпретатора  запоминания   того,  какие  операции  необходимо   выполнить  в
дальнейшем. *Итеративный  процесс*, с  другой стороны,  на каждом  шаге зависит
лишь от конечного количества  переменных состояния, правила, которые определяют
как эти переменные изменяются от шага к шагу, а так же теста на завершение.

Следует  различать итеративные  и  рекурсивные процедуры,  что является  фактом
синтаксиса,  и  порождаемые  процедурами итеративные  и  рекурсивные  процессы.
Рекурсивная процедура  может порождать итеративный процесс,  если интерпретатор
поддерживает  механизм  оптимизации  *хвостовой  рекурсии*  (рекурсивный  вызов
является последней операцией в теле процедуры), то есть позволяет преобразовать
рекурсию в итерацию.

Если  число  шагов   итерации  или  рекурсивных  вызовов   линейно  зависит  от
аргументов  процедуры,  такой   процесс  называется  *линейно-итеративным*  или
*линейно-рекурсивным*, соответственно.

> ...большинство   реализаций   обычных   языков  ...   построены   так,   что
> интерпретация   любой  рекурсивной   процедуры   поглощает  объем   памяти,
> линейно растущий  пропорционально количеству  вызовов процедуры,  даже если
> описываемый  ею процесс  в  принципе итеративен.  Как  следствие, эти  языки
> способны  описывать   итеративные  процессы  только  с   помощью  специальных
> "циклических  конструкций" вроде  do,  repeat, until,  for  и while...  Если
> реализация языка поддерживает хвостовую  рекурсию, то итерацию можно выразить
> с  помощью  обыкновенного  механизма  вызова функций,  так  что  специальные
> циклические конструкции имеют смысл только как синтаксический сахар.

Существует   также  *древовидная   рекурсия*   (например,  рекурсивный   способ
нахождения определённого  числа Фибоначчи). В  общем случае, число  шагов будет
пропорционально числу  вершин дерева  вызовов, а требуемый  объём памяти  - его
максимальной глубине. Несмотря на то, что данный вид рекурсии может быть весьма
неэффективным, он  может быть полезен  при работе с  иерархическими структурами
данных.

При поиске определённого числа  Фибоначчи рекурсивным способом число избыточных
вычислений  (вызов функции  с одинаковыми  значениями аргументов)  колоссально.
Чтобы  избежать подобного,  существует стратегия,  называемая *табуляризацией*,
или  *мемоизацией*,  когда  результат  вычисления  процедуры  для  определённых
параметров сохраняется в некой таблице, и при следующем вызове процедуры с теми
же аргументами результат уже не вычисляется, а выдаётся из таблицы.
